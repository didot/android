/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.tools.idea.monitor.datastore;

import com.android.tools.adtui.Range;
import gnu.trove.TLongArrayList;

import javax.swing.*;
import java.util.*;

public final class SeriesDataStoreImpl implements SeriesDataStore {

  private static final int GENERATE_DATA_THREAD_DELAY = 100;

  private static final DataGenerator CPU_MY_PROCESS_GENERATOR = new DataGenerator(0, 60, 10);

  private static final DataGenerator CPU_OTHER_PROCESSES_GENERATOR = new DataGenerator(0, 30, 10);

  private static final DataGenerator CPU_NUM_THREADS_GENERATOR = new DataGenerator(0, 10, 1);

  private static final DataGenerator CPU_NUM_CONNECTIONS_GENERATOR = new DataGenerator(0, 20, 2);

  private static final DataGenerator DEFAULT_DATA_GENERATOR = new DataGenerator(0, 100, 20);

  private TLongArrayList myTimingData = new TLongArrayList();

  private Map<SeriesDataType, List<Long>> myDataSeriesMap = new HashMap<>();

  private Thread myDataThread;

  private long myStartTime;

  public SeriesDataStoreImpl() {
    startGeneratingData();
  }

  @Override
  public void reset() {
    if(myDataThread != null) {
      myDataThread.interrupt();
    }
  }

  @Override
  public long getTimeAtIndex(int index) {
    return myTimingData.get(index);
  }

  @Override
  public int getClosestTimeIndex(long timeValue) {
    int index = myTimingData.binarySearch(timeValue);
    if (index < 0) {
      // No exact match, returns position to the left of the insertion point.
      // NOTE: binarySearch returns -(insertion point + 1) if not found.
      index = -index - 1;
    }
    return Math.max(0, Math.min(myTimingData.size() - 1, index));
  }

  // TODO: as API changes, fix this method, as it should return a generic value, not a Long.
  @Override
  public Long getValueAtIndex(SeriesDataType type, int index) {
    return myDataSeriesMap.get(type).get(index);
  }

  // TODO: as API changes, fix this method, as it should return a generic value, not a Long.
  @Override
  public SeriesDataList<Long> getSeriesData(SeriesDataType type, Range range) {
    return new SeriesDataList<>(range, this, type);
  }

  // TODO: right now the data is being generated by this method. Replace it with data collected from the device later.
  private void generateData() {
    myTimingData.add(System.currentTimeMillis() - myStartTime);

    for (SeriesDataType type : myDataSeriesMap.keySet()) {
      List<Long> data = myDataSeriesMap.get(type);

      switch (type) {
        case CPU_MY_PROCESS:
          data.add(CPU_MY_PROCESS_GENERATOR.next());
          break;
        case CPU_OTHER_PROCESSES:
          data.add(CPU_OTHER_PROCESSES_GENERATOR.next());
          break;
        case CPU_THREADS:
          data.add(CPU_NUM_THREADS_GENERATOR.next());
          break;
        case NETWORK_CONNECTIONS:
          data.add(CPU_NUM_CONNECTIONS_GENERATOR.next());
          break;
        // TODO: add memory/network generators
        default:
          data.add(DEFAULT_DATA_GENERATOR.next());
          break;
      }
    }
  }

  private void startGeneratingData() {
    for (SeriesDataType type : SeriesDataType.values()) {
      myDataSeriesMap.put(type, new ArrayList<>());
    }
    myStartTime = System.currentTimeMillis();

    myDataThread = new Thread() {
      @Override
      public void run() {
        try {
          while (true) {
            // TODO: come up with a better way of handling thread issues
            SwingUtilities.invokeLater(() -> generateData());

            Thread.sleep(GENERATE_DATA_THREAD_DELAY);
          }
        }
        catch (InterruptedException ignored) {
        }
      }
    };
    myDataThread.start();
  }

  /**
   * Simulated data generator.
   */
  private static class DataGenerator {

    private long myNext;

    private int myMaxVariance;

    private int myMin;

    private int myMax;

    /**
     * Generates simulated data from {@code min} to {@code max} (inclusive).
     * Values generated don't differ more than {@code maxVariance} from the previous generated value.
     */
    DataGenerator(int min, int max, int maxVariance) {
      myMin = min;
      myMax = max;
      myMaxVariance = maxVariance;
      myNext = randomInInterval(min, max);
    }

    long next() {
      long next = myNext;
      myNext = getNextVal();
      return next;
    }

    private long getNextVal() {
      // Next value should not differ from current by more than max variance
      long next = myNext + randomInInterval(-myMaxVariance, myMaxVariance);
      return Math.min(myMax, Math.max(myMin, next));
    }

    /**
     * Returns a random number in an interval.
     *
     * @param min lower bound of the interval (inclusive)
     * @param max upper bound of the interval (inclusive)
     */
    private static long randomInInterval(long min, long max) {
      return (long) Math.floor(Math.random() * (max - min + 1) + min);
    }
  }
}
