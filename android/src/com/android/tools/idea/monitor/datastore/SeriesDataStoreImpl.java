/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.tools.idea.monitor.datastore;

import com.android.tools.adtui.Range;
import com.google.common.collect.HashBasedTable;
import com.google.common.collect.Table;
import gnu.trove.TLongArrayList;

import javax.swing.*;
import java.util.*;

public final class SeriesDataStoreImpl implements SeriesDataStore {

  private static final int GENERATE_DATA_THREAD_DELAY = 100;

  private static final DataGenerator CPU_MY_PROCESS_GENERATOR = new DataGenerator(0, 60, 10);

  private static final DataGenerator CPU_OTHER_PROCESSES_GENERATOR = new DataGenerator(0, 30, 10);

  private static final DataGenerator CPU_NUM_THREADS_GENERATOR = new DataGenerator(0, 10, 1);

  private static final DataGenerator CPU_NUM_CONNECTIONS_GENERATOR = new DataGenerator(0, 20, 2);

  private static final DataGenerator DEFAULT_DATA_GENERATOR = new DataGenerator(0, 100, 20);

  // TODO: Think in a better way to represent seriesDataType x timestamp x seriesData
  private Table<SeriesDataType, TLongArrayList, List<?>> myDataSeriesMap = HashBasedTable.create();

  private Thread myDataThread;

  private long myStartTime;

  private long myCurrentTime;

  public SeriesDataStoreImpl() {
    startGeneratingData();
  }

  @Override
  public void reset() {
    if(myDataThread != null) {
      myDataThread.interrupt();
    }
  }

  @Override
  public long getLatestTime() {
    return myCurrentTime;
  }

  @Override
  public long getTimeAtIndex(SeriesDataType type, int index) {
    Map<TLongArrayList, List<?>> dataMap = myDataSeriesMap.row(type);
    assert dataMap.size() == 1;

    TLongArrayList timeData = dataMap.keySet().iterator().next();
    return timeData.get(index);
  }

  @Override
  public int getClosestTimeIndex(SeriesDataType type, long timeValue) {
    Map<TLongArrayList, List<?>> dataMap = myDataSeriesMap.row(type);
    assert dataMap.size() == 1;

    TLongArrayList timeData = dataMap.keySet().iterator().next();
    int index = timeData.binarySearch(timeValue);
    if (index < 0) {
      // No exact match, returns position to the left of the insertion point.
      // NOTE: binarySearch returns -(insertion point + 1) if not found.
      index = -index - 1;
    }

    return Math.max(0, Math.min(timeData.size() - 1, index));
  }

  @Override
  public <T> T getValueAtIndex(SeriesDataType type, int index) {
    Map<TLongArrayList, List<?>> dataMap = myDataSeriesMap.row(type);
    assert dataMap.size() == 1;

    List<?> seriesData = dataMap.values().iterator().next();
    return (T)seriesData.get(index);
  }

  @Override
  public <T> SeriesDataList<T> getSeriesData(SeriesDataType type, Range range) {
    return new SeriesDataList<>(range, this, type);
  }

  // TODO: right now the data is being generated by this method. Replace it with data collected from the device later.
  private void generateData() {
    myCurrentTime = System.currentTimeMillis() - myStartTime;

    Map<SeriesDataType, Map<TLongArrayList, List<?>>> rowMap = myDataSeriesMap.rowMap();
    for (SeriesDataType dataType : rowMap.keySet()) {
      Map<TLongArrayList, List<?>> series = rowMap.get(dataType);
      for (Map.Entry<TLongArrayList, List<?>> dataList : series.entrySet()) {
        // TODO: come up with cleaner API, as this casting is wrong, i.e mDataSeriesMap returns a generic list
        dataList.getKey().add(myCurrentTime);
        List<Long> castedData = (List<Long>)dataList.getValue();
        switch (dataType) {
          case CPU_MY_PROCESS:
            castedData.add(CPU_MY_PROCESS_GENERATOR.next());
            break;
          case CPU_OTHER_PROCESSES:
            castedData.add(CPU_OTHER_PROCESSES_GENERATOR.next());
            break;
          case CPU_THREADS:
            castedData.add(CPU_NUM_THREADS_GENERATOR.next());
            break;
          case NETWORK_CONNECTIONS:
            castedData.add(CPU_NUM_CONNECTIONS_GENERATOR.next());
            break;
          // TODO: add memory/network generators
          default:
            castedData.add(DEFAULT_DATA_GENERATOR.next());
            break;
        }
      }
    }
  }

  private void startGeneratingData() {
    for (SeriesDataType type : SeriesDataType.values()) {
      myDataSeriesMap.put(type, new TLongArrayList(), new ArrayList<>());
    }
    myStartTime = System.currentTimeMillis();

    myDataThread = new Thread() {
      @Override
      public void run() {
        try {
          while (true) {
            // TODO: come up with a better way of handling thread issues
            SwingUtilities.invokeLater(() -> generateData());

            Thread.sleep(GENERATE_DATA_THREAD_DELAY);
          }
        }
        catch (InterruptedException ignored) {
        }
      }
    };
    myDataThread.start();
  }

  /**
   * Simulated data generator.
   */
  private static class DataGenerator {

    private long myNext;

    private int myMaxVariance;

    private int myMin;

    private int myMax;

    /**
     * Generates simulated data from {@code min} to {@code max} (inclusive).
     * Values generated don't differ more than {@code maxVariance} from the previous generated value.
     */
    DataGenerator(int min, int max, int maxVariance) {
      myMin = min;
      myMax = max;
      myMaxVariance = maxVariance;
      myNext = randomInInterval(min, max);
    }

    long next() {
      long next = myNext;
      myNext = getNextVal();
      return next;
    }

    private long getNextVal() {
      // Next value should not differ from current by more than max variance
      long next = myNext + randomInInterval(-myMaxVariance, myMaxVariance);
      return Math.min(myMax, Math.max(myMin, next));
    }

    /**
     * Returns a random number in an interval.
     *
     * @param min lower bound of the interval (inclusive)
     * @param max upper bound of the interval (inclusive)
     */
    private static long randomInInterval(long min, long max) {
      return (long) Math.floor(Math.random() * (max - min + 1) + min);
    }
  }
}
