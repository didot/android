/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.tools.idea.editors.gfxtrace.lang.glsl.lexer;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;

import javax.annotation.Nullable;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class GlslLexerBase {
  // Tokens for 2-char operators which include '='
  private static final Set<Character> EQUAL_CHARS = new HashSet<>(Arrays.asList('=', '!', '>', '<', '+', '-', '*', '/', '%'));

  /**
   * Keywords for GLSL.
   * @see <a href="https://www.khronos.org/registry/gles/specs/3.0/GLSL_ES_Specification_3.00.3.pdf">documentation</a>
   */
  private static final Set<String> KEYWORDS = new HashSet<>(Arrays.asList(
    "const", "uniform", "layout", "centroid", "flat", "smooth", "break", "continue", "do", "for", "while", "switch", "case", "default",
    "if", "else", "in", "out", "inout", "float", "int", "void", "bool", "true", "false", "invariant", "discard", "return", "mat2", "mat3",
    "mat4", "mat2x2", "mat2x3", "mat2x4", "mat3x2", "mat3x3", "mat3x4", "mat4x2", "mat4x3", "mat4x4", "vec2", "vec3", "vec4", "ivec2",
    "ivec3", "ivec4", "bvec2", "bvec3", "bvec4", "uint", "uvec2", "uvec3", "uvec4", "lowp", "mediump", "highp", "precision", "sampler2D",
    "sampler3D", "samplerCube", "sampler2DShadow", "samplerCubeShadow", "sampler2DArray", "sampler2DArrayShadow", "isampler2D",
    "isampler3D", "isamplerCube", "isampler2DArray", "usampler2D", "usampler3D", "usamplerCube", "usampler2DArray", "struct"
  ));

  // Keywords for preprocessor commands.
  private static final Set<String> PREPROCESSOR_KEYWORDS = new HashSet<>(Arrays.asList(
    "define", "undef", "if", "ifdef", "ifndef", "else", "elif", "endif", "error", "pragma", "extension", "version", "line"
  ));

  // Map of syntactic sugar accessors.
  private static final ImmutableMap<Character, Integer> COMPONENTS_MAP =
    ImmutableMap.<Character, Integer>builder()
      .put('x', 0b001)
      .put('y', 0b001)
      .put('z', 0b001)
      .put('w', 0b001)
      .put('r', 0b010)
      .put('g', 0b010)
      .put('b', 0b010)
      .put('a', 0b010)
      .put('s', 0b100)
      .put('t', 0b100)
      .put('p', 0b100)
      .put('q', 0b100)
      .build();

  // Input buffer and position
  private final char[] buffer;
  private int pos;

  private final List<Token> tokens;

  private int openParenStackDepth = 0;

  public GlslLexerBase(CharSequence input, int initialStackDepth) {
    this.buffer = input.toString().toCharArray();
    // Empirical measurements show roughly 1 token per 8 characters in buffer.
    this.tokens = Lists.newArrayListWithExpectedSize(buffer.length / 8);
    this.pos = 0;
    this.openParenStackDepth = initialStackDepth;

    tokenize();
  }

  /**
   * The number of unclosed open-parens ("(", '{', '[') at the end of this string.
   */
  public int getOpenParenStackDepth() {
    return openParenStackDepth;
  }


  /**
   * Returns the (mutable) list of tokens generated by the GlslLexerBase.
   */
  public List<Token> getTokens() {
    return tokens;
  }

  private void popParen() {
    if (openParenStackDepth > 0) {
      openParenStackDepth--;
    }
  }

  /**
   * invariant: symbol positions are half-open intervals.
   */
  private void addToken(TokenKind kind, int left, int right) {
    addToken(kind, left, right, null);
  }

  /**
   * Used for debugging only for now.
   */
  private void addToken(TokenKind kind, int left, int right, @Nullable Object value) {
    tokens.add(new Token(kind, left, right, value));
  }

  /**
   * Parses an end-of-line sequence, handling statement indentation correctly.
   *
   * UNIX newlines are assumed (LF). Carriage returns are always ignored.
   *
   * ON ENTRY: 'pos' is the index of the char after '\n'.
   * ON EXIT: 'pos' is the index of the next non-space char after '\n'.
   */
  protected void newline() {
    addToken(TokenKind.NEWLINE, pos - 1, pos);
  }

  /**
   * Collapse adjacent whitespace characters into a single token
   */
  private void addWhitespace() {
    int oldPos = pos - 1;
    while (pos < buffer.length) {
      switch (buffer[pos]) {
        case ' ':
        case '\t':
        case '\r':
          pos++;
          break;
        default:
          addToken(TokenKind.WHITESPACE, oldPos, pos, bufferSlice(oldPos, pos));
          return;
      }
    }
    addToken(TokenKind.WHITESPACE, oldPos, pos, bufferSlice(oldPos, pos));
  }

  /**
   * Scans a string literal delimited by 'quot', containing escape sequences.
   *
   * <p>ON ENTRY: 'pos' is 1 + the index of the first delimiter
   * ON EXIT: 'pos' is 1 + the index of the last delimiter.
   */
  private void escapedStringLiteral(boolean isRaw) {
    int oldPos = isRaw ? pos - 2 : pos - 1;

    // more expensive second choice that expands escaped into a buffer
    StringBuilder literal = new StringBuilder();
    while (pos < buffer.length) {
      char c = buffer[pos];
      pos++;
      switch (c) {
        case '\n':
          addToken(TokenKind.STRING, oldPos, pos - 1, literal.toString());
          newline();
          return;
        case '\\':
          if (pos == buffer.length) {
            addToken(TokenKind.STRING, oldPos, pos - 1, literal.toString());
            return;
          }
          if (isRaw) {
            // Insert \ and the following character.
            literal.append('\\');
            literal.append(buffer[pos]);
            pos++;
            break;
          }
          c = buffer[pos];
          pos++;
          switch (c) {
            case '\n':
              // ignore end of line character
              break;
            case 'n':
              literal.append('\n');
              break;
            case 'r':
              literal.append('\r');
              break;
            case 't':
              literal.append('\t');
              break;
            case '\\':
              literal.append('\\');
              break;
            case '\'':
              literal.append('\'');
              break;
            case '"':
              literal.append('"');
              break;
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7': { // octal escape
              int octal = c - '0';
              if (pos < buffer.length) {
                c = buffer[pos];
                if (c >= '0' && c <= '7') {
                  pos++;
                  octal = (octal << 3) | (c - '0');
                  if (pos < buffer.length) {
                    c = buffer[pos];
                    if (c >= '0' && c <= '7') {
                      pos++;
                      octal = (octal << 3) | (c - '0');
                    }
                  }
                }
              }
              literal.append((char)(octal & 0xff));
              break;
            }
            case 'a':
            case 'b':
            case 'f':
            case 'N':
            case 'u':
            case 'U':
            case 'v':
            case 'x':
              break;
            default:
              // unknown char escape => "\literal"
              literal.append('\\');
              literal.append(c);
              break;
          }
          break;
        case '\'':
        case '"':
          // Matching close-delimiter, all done.
          addToken(TokenKind.STRING, oldPos, pos, literal.toString());
          return;
        default:
          literal.append(c);
          break;
      }
    }
    addToken(TokenKind.STRING, oldPos, pos, literal.toString());
  }

  /**
   * Scans a string literal delimited by 'quot'.
   *
   * ON ENTRY: 'pos' is 1 + the index of the first delimiter
   * ON EXIT: 'pos' is 1 + the index of the last delimiter.
   *
   * @param isRaw if true, do not escape the string.
   */
  private void addStringLiteral(char quot, boolean isRaw) {
    int oldPos = isRaw ? pos - 2 : pos - 1;
    int start = pos;

    // first quick optimistic scan for a simple non-escaped string
    while (pos < buffer.length) {
      char c = buffer[pos++];
      switch (c) {
        case '\n':
          addToken(TokenKind.STRING, oldPos, pos - 1, bufferSlice(start, pos - 1));
          newline();
          return;
        case '\\':
          if (isRaw) {
            // skip the next character
            pos++;
            break;
          }
          // oops, hit an escape, need to start over & build a new string buffer
          pos = oldPos + 1;
          escapedStringLiteral(false);
          return;
        case '\'':
        case '"':
          if (c == quot) {
            // close-quote, all done.
            addToken(TokenKind.STRING, oldPos, pos, bufferSlice(start, pos - 1));
            return;
          }
      }
    }

    addToken(TokenKind.STRING, oldPos, pos, bufferSlice(start, pos));
  }

  private String scanIdentifier() {
    int oldPos = pos - 1;
    if (Character.isJavaIdentifierStart(buffer[pos])) {
      pos++;
      while (pos < buffer.length && Character.isJavaIdentifierPart(buffer[pos])) {
        pos++;
      }
    }
    return bufferSlice(oldPos, pos);
  }

  /**
   * Scans an identifier or keyword.
   *
   * ON ENTRY: 'pos' is 1 + the index of the first char in the identifier.
   * ON EXIT: 'pos' is 1 + the index of the last char in the identifier.
   */
  private void addIdentifierOrKeyword() {
    int oldPos = pos - 1;
    String id = scanIdentifier();
    addToken((KEYWORDS.contains(id)) ? TokenKind.KEYWORD : TokenKind.WHITESPACE, oldPos, pos, id);
  }

  /**
   * Scans all the symbols which may look like an integer. Ensured to start with a digit.
   */
  private String scanInteger() {
    int oldPos = pos - 1;
    while (pos < buffer.length) {
      char c = buffer[pos];
      switch (c) {
        case 'X':
        case 'x':
        case 'a':
        case 'A':
        case 'b':
        case 'B':
        case 'c':
        case 'C':
        case 'd':
        case 'D':
        case 'e':
        case 'E':
        case 'f':
        case 'F':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          pos++;
          break;
        default:
          return bufferSlice(oldPos, pos);
      }
    }
    return bufferSlice(oldPos, pos);
  }

  /**
   * Scans all the symbols which may look like a float. Ensured to start with a digit.
   * Call this before {@link #scanInteger()}. Most integers will be treated as floats in this function.
   * TODO: Fix the above issue if semantic is included.
   */
  private String scanFloat() {
    int oldPos = pos - 1;
    while (pos < buffer.length) {
      char c = buffer[pos];
      switch (c) {
        case 'e':
        case 'E':
        case 'f':
        case 'F':
        case 'l':
        case 'L':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case '.':
        case '+':
        case '-':
          pos++;
          break;
        default:
          return bufferSlice(oldPos, pos);
      }
    }
    return bufferSlice(oldPos, pos);
  }

  /**
   * Scans an integer literal.
   *
   * ON ENTRY: 'pos' is 1 + the index of the first char in the literal.
   * ON EXIT: 'pos' is 1 + the index of the last char in the literal.
   */
  private void addInteger() {
    int oldPos = pos - 1;
    String literal = scanInteger();

    addToken(TokenKind.NUMERIC, oldPos, pos, literal);
  }

  /**
   * Tries to scan a float literal.
   *
   * ON ENTRY: 'pos' is 1 + the index of the first char in the literal.
   * ON EXIT: 'pos' is 1 + the index of the last char in the literal.
   *
   * @return whether literal was a float.
   */
  private boolean addFloat() {
    int oldPos = pos - 1;
    String literal = scanFloat();

    // Some dumb check, we also call addFloat() if we meet the dot (e.g. there may be .5f literal).
    if (literal.equals(".")) {
      pos = oldPos + 1;
      return false;
    }
    addToken(TokenKind.NUMERIC, oldPos, pos, literal);
    return true;
  }

  private String scanVecScalarComponents() {
    int oldPos = pos;
    int groupMatch = 0b111;
    while (pos < buffer.length) {
      char c = buffer[pos];
      if (Character.isJavaIdentifierPart(c)) {
        groupMatch &= COMPONENTS_MAP.getOrDefault(c, 0);
        if (groupMatch == 0) {
          return null;
        }
        pos++;
      }
      else {
        if (groupMatch != 7) {
          break;
        }
        return null;
      }
    }
    return bufferSlice(oldPos, pos);
  }

  private boolean addComponentsToken() {
    final int oldPos = pos;
    final String components = scanVecScalarComponents();
    if (components != null) {
      addToken(TokenKind.COMPONENTS, oldPos, pos, components);
      return true;
    }
    pos = oldPos;
    return false;
  }

  /**
   * Tokenizes a two-char operator.
   *
   * @return true if it tokenized an operator
   */
  private boolean tokenizeTwoChars() {
    if (pos + 2 >= buffer.length) {
      return false;
    }
    char c1 = buffer[pos];
    char c2 = buffer[pos + 1];
    TokenKind tok = null;
    if ((EQUAL_CHARS.contains(c1) && c2 == '=') || (c2 == '*' && c1 == '*')) {
      tok = TokenKind.BINARY_OP;
    }
    if (tok == null) {
      return false;
    }
    addToken(tok, pos, pos + 2, String.format("%c%c", c1, c2));
    return true;
  }

  /**
   * Performs tokenization of the character buffer of file contents provided to
   * the constructor.
   */
  private void tokenize() {
    while (pos < buffer.length) {
      if (tokenizeTwoChars()) {
        pos += 2;
        continue;
      }
      char c = buffer[pos];
      pos++;
      switch (c) {
        case '{': {
          addToken(TokenKind.LBRACE, pos - 1, pos);
          openParenStackDepth++;
          break;
        }
        case '(': {
          addToken(TokenKind.LPAREN, pos - 1, pos);
          openParenStackDepth++;
          break;
        }
        case '[': {
          addToken(TokenKind.LBRACKET, pos - 1, pos);
          openParenStackDepth++;
          break;
        }
        case '}': {
          addToken(TokenKind.RBRACE, pos - 1, pos);
          popParen();
          break;
        }
        case ')': {
          addToken(TokenKind.RPAREN, pos - 1, pos);
          popParen();
          break;
        }
        case ']': {
          addToken(TokenKind.RBRACKET, pos - 1, pos);
          popParen();
          break;
        }
        case ':': {
          addToken(TokenKind.SPECIAL, pos - 1, pos, ":");
          break;
        }
        case ',': {
          addToken(TokenKind.COMMA, pos - 1, pos);
          break;
        }
        case '+':
        case '-':
        case '=':
        case '%':
        case '<':
        case '>': {
          addToken(TokenKind.BINARY_OP, pos - 1, pos, Character.toString(c));
          break;
        }
        case '/': {
          int oldPos = pos - 1;
          if (!addCommentToken(oldPos)) {
            pos = oldPos + 1;
            addToken(TokenKind.BINARY_OP, pos - 1, pos, "/");
          }
          break;
        }
        case ';': {
          addToken(TokenKind.SEMI, pos - 1, pos);
          break;
        }
        case '.': {
          if (!addFloat()) {
            addToken(TokenKind.DOT, pos - 1, pos);
            // Try to add a component token.
            addComponentsToken();
          }
          break;
        }
        case '*': {
          // Although this may be binary operator - but we still don't care.
          addToken(TokenKind.SPECIAL, pos - 1, pos, "*");
          break;
        }
        case ' ':
        case '\t':
        case '\r': {
          addWhitespace();
          break;
        }
        // TODO: WRONG!!!!!
        case '\\': {
          // Backslash character is valid only at the end of a line (or in a string)
          if (pos + 1 < buffer.length && buffer[pos] == '\n') {
            // continue reading the next line
            pos++;
          }
          else {
            addToken(TokenKind.ILLEGAL, pos - 1, pos, Character.toString(c));
          }
          break;
        }
        case '\n': {
          newline();
          break;
        }
        case '#': {
          if (!Character.isJavaIdentifierPart(buffer[pos]) || !addPreprocessorToken()) {
            addToken(TokenKind.SPECIAL, pos - 1, pos, "#");
          }
          break;
        }
        case '\'':
        case '\"': {
          addStringLiteral(c, false);
          break;
        }
        default: {
          if (Character.isDigit(c)) {
            boolean num = addFloat();
            if (!num) {
              addInteger();
            }
          }
          else if (Character.isJavaIdentifierStart(c)) {
            addIdentifierOrKeyword();
          }
          else {
            addToken(TokenKind.ILLEGAL, pos - 1, pos, Character.toString(c));
          }
          break;
        } // default
      } // switch
    } // while
  }

  /**
   * Returns parts of the source buffer based on offsets
   *
   * @param start the beginning offset for the slice
   * @param end   the offset immediately following the slice
   * @return the text at offset start with length end - start
   */
  private String bufferSlice(int start, int end) {
    return new String(this.buffer, start, end - start);
  }

  private boolean addCommentToken(int oldPos) {
    int c;
    if (pos < buffer.length) {
      if (buffer[pos] == '/') {
        while (pos < buffer.length) {
          c = buffer[pos];
          if (c == '\n') {
            break;
          }
          else {
            pos++;
          }
        }
        addToken(TokenKind.COMMENT, oldPos, pos, bufferSlice(oldPos, pos));
        return true;
      }
      if (buffer[pos] == '*') {
        pos++;
        while (pos < buffer.length) {
          c = buffer[pos];
          pos++;
          if (c == '*' && pos < buffer.length && buffer[pos] == '/') {
            pos++;
            break;
          }
        }
        addToken(TokenKind.COMMENT, oldPos, pos, bufferSlice(oldPos, pos));
        return true;
      }
    }
    return false;
  }

  private boolean addPreprocessorToken() {
    int oldPos = pos - 1;
    // Skip the '#' char.
    pos++;
    String s = scanIdentifier();
    boolean kw = PREPROCESSOR_KEYWORDS.contains(s);
    if (kw) {
      addToken(TokenKind.PREPROCESSOR, oldPos, pos);
    }
    else {
      pos = oldPos + 1;
    }
    return kw;
  }
}
