/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.tools.idea.res

import com.android.SdkConstants
import com.android.utils.concurrency.CacheUtils
import com.google.common.base.MoreObjects
import com.google.common.cache.Cache
import com.google.common.cache.CacheBuilder
import com.intellij.openapi.components.ServiceManager
import com.intellij.openapi.project.Project
import com.intellij.openapi.vfs.VirtualFile
import com.intellij.psi.*
import com.intellij.psi.impl.file.PsiPackageImpl
import com.intellij.psi.search.GlobalSearchScope
import com.intellij.psi.search.PsiSearchScopeUtil
import org.jetbrains.android.augment.AndroidLightClassBase

/**
 * [PsiPackage] for packages that contain classes generated by aapt.
 *
 * In the IDE we implement such classes as light PSI classes (with no corresponding [VirtualFile]s) and this requires some special treatment
 * from the containing package.
 *
 * Keep in mind that in most projects there is real code in this package, not just the R class. The behavior cannot diverge too much from a
 * "real" [PsiPackage], otherwise various IDE features stop working.
 *
 * @see AndroidLightClassBase
 * @see ProjectSystemPsiElementFinder
 * @see LightResourceClassService
 */
class AndroidLightPackage private constructor(
  manager: PsiManager,
  qualifiedName: String
) : PsiPackageImpl(manager, qualifiedName) {

  companion object {
    @JvmStatic
    fun withName(packageName: String, project: Project): PsiPackage {
      return ServiceManager.getService(project, InstanceCache::class.java).get(packageName)
    }
  }

  /**
   * Overrides [PsiPackageImpl.isValid] to ignore what files exist on disk. [AndroidLightPackage] instances are only used if the right
   * [PsiElementFinder] decided there are light R classes with this package name, so the package is valid even if there are no physical
   * files in corresponding directories.
   */
  override fun isValid(): Boolean {
    return project.isDisposed.not()
  }

  /**
   * Returns true if there are corresponding physical directories to navigate to.
   */
  override fun canNavigate(): Boolean {
    return super.isValid()
  }

  override fun toString(): String {
    return MoreObjects.toStringHelper(this).addValue(qualifiedName).toString()
  }

  /**
   * Finds classes with the given short name in this package in the given scope.
   *
   * Naive implementation that just calls [JavaPsiFacade] which in turn will call [PsiElementFinder] implementations.
   * [PsiPackageImpl] maintains a cached copy of all classes in this package in the entire project (ignoring scope) and then filters
   * it using [PsiSearchScopeUtil.isInScope]. This doesn't work in our case, because R classes in this
   * package are light and don't have corresponding [VirtualFile]s so [PsiSearchScopeUtil] always thinks they are in scope.
   *
   * When delegating to [JavaPsiFacade], the scope is handled in the implementations of [LightResourceClassService].
   *
   * @see ProjectLightResourceClassService.getLightRClasses
   */
  override fun findClassByShortName(name: String, scope: GlobalSearchScope): Array<PsiClass> {
    return if (name == SdkConstants.R_CLASS || name == SdkConstants.FN_MANIFEST_BASE) {
      JavaPsiFacade.getInstance(project).findClasses("$qualifiedName.${name}", scope)
    }
    else {
      super.findClassByShortName(name, scope)
    }
  }

  /**
   * Project service responsible for interning instances of [AndroidLightPackage] with a given name.
   */
  class InstanceCache(private val psiManager: PsiManager) {
    /**
     * Cache of [PsiPackage] instances for a given package name.
     */
    private val packageCache: Cache<String, PsiPackage> = CacheBuilder.newBuilder().softValues().build()

    fun get(name: String): PsiPackage = CacheUtils.getAndUnwrap(packageCache, name) { AndroidLightPackage(psiManager, name) }
  }
}

