/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* SQLite grammar adapted from http://www.sqlite.org/docsrc/doc/trunk/art/syntax/all-bnf.html
 * This should correspond directly to diagrams in the "SQL Syntax" part of SQLite documentation,
 * e.g. https://sqlite.org/lang_select.html
 *
 * Unfortunately the grammar linked above skips the most basic definitions, like string-literal,
 * table-name or digit, so we need to fill in these gaps ourselves.
 *
 * The grammar for expressions (`expr`) also cannot be used as-is because of limitations of Grammar-Kit.
 *
 * This file is used by Grammar-Kit to generate the lexer, parser, node types and PSI classes for Room SQL.
 */

{
  parserClass="com.android.tools.idea.lang.roomSql.parser.RoomSqlParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Room"
  psiImplClassSuffix="Impl"
  psiPackage="com.android.tools.idea.lang.roomSql.psi"
  psiImplPackage="com.android.tools.idea.lang.roomSql.psi.impl"

  elementTypeHolderClass="com.android.tools.idea.lang.roomSql.psi.RoomPsiTypes"
  elementTypeClass="com.android.tools.idea.lang.roomSql.psi.RoomAstNodeType"
  tokenTypeClass="com.android.tools.idea.lang.roomSql.psi.RoomTokenType"

  classHeader='generatedFilesHeader.txt'

  tokens=[
    // Define some keywords here, so that Grammar-Kit's live preview works. In the flex file we manually insert
    // %caseless, in the preview only upper case keywords work.
    SELECT='SELECT'
    FROM='FROM'
    WHERE='WHERE'
    DISTINCT='DISTINCT'
    DELETE='DELETE'
    INSERT='INSERT'
    INTO='INTO'
    VALUES='VALUES'

    NUMERIC_LITERAL='regexp:([0-9]+(\.[0-9]*)?|\.[0-9]+)(E(\+|-)?[0-9]+)?'
    // TODO: Figure out what the exact rules for names of various entities and handle quoting/escaping.
    NAME_LITERAL='regexp:[a-z]\w*'
    PARAMETER_NAME='regexp::[a-z]\w*' // TODO: support other formats
    STRING_LITERAL='regexp:"[^"]*"' // TODO
    BLOB_LITERAL='regexp:x"[^"]*"' // TODO

    COMMENT='regexp:--[^\r\n]' // TODO

    // Grammar-Kit's live preview emulates PsiBuilder's behavior of ignoring whitespace, by
    // looking for a token type that matches a space and is not used otherwise. Here's one:
    WHITE_SPACE_FOR_LIVE_PREVIEW='regexp:\s+'
  ]
}

sql_stmt_list ::= ( sql_stmt )? ( ';' ( sql_stmt )? )*

sql_stmt ::=
  ( EXPLAIN ( QUERY PLAN )? )?
  ( alter_table_stmt
  | analyze_stmt
  | attach_stmt
  | begin_stmt
  | commit_stmt
  | create_index_stmt
  | create_table_stmt
  | create_trigger_stmt
  | create_view_stmt
  | create_virtual_table_stmt
  | delete_stmt
  | delete_stmt_limited
  | detach_stmt
  | drop_index_stmt
  | drop_table_stmt
  | drop_trigger_stmt
  | drop_view_stmt
  | insert_stmt
  | pragma_stmt
  | reindex_stmt
  | release_stmt
  | rollback_stmt
  | savepoint_stmt
  | select_stmt
  | update_stmt
  | update_stmt_limited
  | vacuum_stmt
  )

alter_table_stmt ::= ALTER TABLE ( database_name '.' )? table_name ( RENAME TO table_name | ADD ( COLUMN )? column_def )

table_name ::= NAME_LITERAL

database_name ::= NAME_LITERAL

analyze_stmt ::= ANALYZE ( database_name | table_or_index_name | database_name '.' table_or_index_name )?

table_or_index_name ::= NAME_LITERAL

attach_stmt ::= ATTACH ( DATABASE )? expr AS database_name

begin_stmt ::= BEGIN ( DEFERRED | IMMEDIATE | EXCLUSIVE )? ( TRANSACTION )?

commit_stmt ::= ( COMMIT | END ) ( TRANSACTION )?

rollback_stmt ::= ROLLBACK ( TRANSACTION )? ( TO ( SAVEPOINT )? savepoint_name )?

savepoint_name ::= NAME_LITERAL

savepoint_stmt ::= SAVEPOINT savepoint_name

release_stmt ::= RELEASE ( SAVEPOINT )? savepoint_name

create_index_stmt ::=
  CREATE ( UNIQUE )? INDEX ( IF NOT EXISTS )?
  ( database_name '.' )? index_name ON table_name '(' indexed_column ( ',' indexed_column )* ')'
  ( WHERE expr )?

index_name ::= NAME_LITERAL

indexed_column ::= column_name ( COLLATE collation_name )? ( ASC | DESC )?

column_name ::= NAME_LITERAL

collation_name ::= NAME_LITERAL

create_table_stmt ::=
  CREATE ( TEMP | TEMPORARY )? TABLE ( IF NOT EXISTS )?
  ( database_name '.' )? table_name
  ( '(' column_def ( ',' column_def )* ( ',' table_constraint )* ')' ( WITHOUT ROWID )? | AS select_stmt )

column_def ::= column_name ( type_name )? ( column_constraint )*

type_name ::= NAME_LITERAL ( '(' signed_number ')' | '(' signed_number ',' signed_number ')' )?

column_constraint ::=
  ( CONSTRAINT  NAME_LITERAL )?
  ( PRIMARY KEY ( ASC | DESC )? conflict_clause ( AUTOINCREMENT )?
  | NOT NULL conflict_clause
  | UNIQUE conflict_clause
  | CHECK '(' expr ')'
  | DEFAULT ( signed_number | literal_value | '(' expr ')' )
  | COLLATE collation_name | foreign_key_clause )

// TODO: move this to lexer, so we can highlight the whole number.
signed_number ::= ( '+' | '-' )? NUMERIC_LITERAL

table_constraint ::=
  ( CONSTRAINT  NAME_LITERAL )?
  ( ( PRIMARY KEY | UNIQUE ) '(' indexed_column ( ',' indexed_column )* ')' conflict_clause
  | CHECK '(' expr ')'
  | FOREIGN KEY '(' column_name ( ',' column_name )* ')' foreign_key_clause )

foreign_key_clause ::=
  REFERENCES foreign_table ( '(' column_name ( ',' column_name )* ')' )?
  ( ( ON ( DELETE | UPDATE ) ( SET NULL | SET DEFAULT | CASCADE | RESTRICT | NO ACTION ) | MATCH  NAME_LITERAL ) )?
  ( ( NOT )? DEFERRABLE ( INITIALLY DEFERRED | INITIALLY IMMEDIATE )? )?

foreign_table ::= NAME_LITERAL

conflict_clause ::= ( ON CONFLICT ( ROLLBACK | ABORT | FAIL | IGNORE | REPLACE ) )?

create_trigger_stmt ::=
  CREATE ( TEMP | TEMPORARY )? TRIGGER ( IF NOT EXISTS )?
  ( database_name '.' )? trigger_name ( BEFORE | AFTER | INSTEAD OF )?
  ( DELETE | INSERT | UPDATE ( OF column_name ( ',' column_name )* )? ) ON table_name
  ( FOR EACH ROW )? ( WHEN expr )?
  BEGIN ( update_stmt | insert_stmt | delete_stmt | select_stmt ) ';' END

trigger_name ::= NAME_LITERAL

create_view_stmt ::=
  CREATE ( TEMP | TEMPORARY )? VIEW ( IF NOT EXISTS )?
  ( database_name '.' )? view_name AS select_stmt

view_name ::= NAME_LITERAL

create_virtual_table_stmt ::=
  CREATE VIRTUAL TABLE ( IF NOT EXISTS )?
  ( database_name '.' )? table_name
  USING module_name ( '(' module_argument ( ',' module_argument )* ')' )?

module_name ::= NAME_LITERAL
module_argument ::= NAME_LITERAL

with_clause ::= WITH ( RECURSIVE )? cte_table_name AS '(' select_stmt ')' ( ',' cte_table_name AS '(' select_stmt ')' )*

cte_table_name ::= table_name ( '(' column_name ( ',' column_name )* ')' )?

// TODO: Why is this not used?
//recursive_cte ::= cte_table_name AS '(' initial_select ( UNION | UNION ALL ) recursive_select ')'

common_table_expression ::= table_name ( '(' column_name ( ',' column_name )* ')' )? AS '(' select_stmt ')'

delete_stmt ::= ( with_clause )? DELETE FROM qualified_table_name
( WHERE expr )?

delete_stmt_limited ::=
  ( with_clause )? DELETE FROM qualified_table_name
  ( WHERE expr )?
  ( ( ORDER BY ordering_term ( ',' ordering_term )* )?
  LIMIT expr ( ( OFFSET | ',' ) expr )? )?

detach_stmt ::= DETACH ( DATABASE )? database_name

drop_index_stmt ::= DROP INDEX ( IF EXISTS )? ( database_name '.' )? index_name

drop_table_stmt ::= DROP TABLE ( IF EXISTS )? ( database_name '.' )? table_name

drop_trigger_stmt ::= DROP TRIGGER ( IF EXISTS )? ( database_name '.' )? trigger_name

drop_view_stmt ::= DROP VIEW ( IF EXISTS )? ( database_name '.' )? view_name

// TODO: rewrite to avoid left recursion unsupported by Grammar_Kit.
expr ::=
  literal_value
  | bind_parameter
  | ( ( database_name '.' )? table_name '.' )? column_name
  | unary_operator expr
  //| expr binary_operator expr
  | function_name '(' ( ( DISTINCT )? expr ( ',' expr )* | '*' )? ')'
  | '(' expr ')'
  | CAST '(' expr AS type_name ')'
  //| expr COLLATE collation_name
  //| expr ( NOT )? ( LIKE | GLOB | REGEXP | MATCH ) expr ( ESCAPE expr )?
  //| expr ( ISNULL | NOTNULL | NOT NULL )
  //| expr IS ( NOT )? expr
  //| expr ( NOT )? BETWEEN expr AND expr
  //| expr ( NOT )? IN ( '(' ( select_stmt | expr ( ',' expr )* )? ')' | ( database_name '.' )? table_name )
  | ( ( NOT )? EXISTS )? '(' select_stmt ')'
  | CASE ( expr )? WHEN expr THEN expr ( ELSE expr )? END
  | raise_function

function_name ::= NAME_LITERAL

//binary_operator ::= '+' | '-' // TODO

unary_operator ::= '+' | '-' | '!' // TODO

bind_parameter ::= PARAMETER_NAME

raise_function ::= RAISE '(' ( IGNORE | ( ROLLBACK | ABORT | FAIL ) ',' error_message ) ')'

error_message ::= STRING_LITERAL // TODO

literal_value ::=
  NUMERIC_LITERAL
  | STRING_LITERAL
  | BLOB_LITERAL
  | NULL
  | CURRENT_TIME
  | CURRENT_DATE
  | CURRENT_TIMESTAMP

insert_stmt ::=
  ( with_clause )? ( INSERT | REPLACE | INSERT OR REPLACE | INSERT OR ROLLBACK | INSERT OR ABORT | INSERT OR FAIL | INSERT OR IGNORE ) INTO
  ( database_name '.' )? table_name ( '(' column_name ( ',' column_name )* ')' )?
  ( VALUES '(' expr ( ',' expr )* ')' ( ',' '(' expr ( ',' expr )* ')' )* | select_stmt | DEFAULT VALUES )

pragma_stmt ::= PRAGMA ( database_name '.' )? pragma_name ( '=' pragma_value | '(' pragma_value ')' )?

pragma_name ::= NAME_LITERAL // TODO

pragma_value ::= signed_number | NAME_LITERAL | STRING_LITERAL // TODO

reindex_stmt ::= REINDEX ( collation_name | ( database_name '.' )? ( table_name | index_name ) )?

select_stmt ::=
  ( WITH ( RECURSIVE )? common_table_expression ( ',' common_table_expression )* )?
  ( SELECT ( DISTINCT | ALL )? result_column ( ',' result_column )*
  ( FROM ( table_or_subquery ( ',' table_or_subquery )* | join_clause ) )?
  ( WHERE expr )?
  ( GROUP BY expr ( ',' expr )* ( HAVING expr )? )? | VALUES '(' expr ( ',' expr )* ')' ( ',' '(' expr ( ',' expr )* ')' )* ) ( compound_operator ( SELECT ( DISTINCT | ALL )? result_column ( ',' result_column )*
  ( FROM ( table_or_subquery ( ',' table_or_subquery )* | join_clause ) )?
  ( WHERE expr )?
  ( GROUP BY expr ( ',' expr )* ( HAVING expr )? )? | VALUES '(' expr ( ',' expr )* ')' ( ',' '(' expr ( ',' expr )* ')' )* ) )*
  ( ORDER BY ordering_term ( ',' ordering_term )* )?
  ( LIMIT expr ( ( OFFSET | ',' ) expr )? )?

join_clause ::= table_or_subquery ( join_operator table_or_subquery join_constraint )?

table_or_subquery ::=
  ( database_name '.' )? table_name ( ( AS )? table_alias )? ( INDEXED BY index_name | NOT INDEXED )?
  | '(' ( table_or_subquery ( ',' table_or_subquery )* | join_clause ) ')'
  | '(' select_stmt ')' ( ( AS )? table_alias )?

table_alias ::= NAME_LITERAL

result_column ::=
  '*'
  | table_name '.*' // TODO: spaces between dot and star?
  | expr ( ( AS )? column_alias )?

column_alias ::= NAME_LITERAL

join_operator ::= ',' | ( NATURAL )? ( LEFT ( OUTER )? | INNER | CROSS )? JOIN

join_constraint ::= ( ON expr | USING '(' column_name ( ',' column_name )* ')' )?

ordering_term ::= expr ( COLLATE collation_name )? ( ASC | DESC )?

compound_operator ::= UNION | UNION ALL | INTERSECT | EXCEPT

update_stmt ::= ( with_clause )? UPDATE ( OR ROLLBACK | OR ABORT | OR REPLACE | OR FAIL | OR IGNORE )? qualified_table_name
SET column_name '=' expr ( ',' column_name '=' expr )* ( WHERE expr )?

update_stmt_limited ::= ( with_clause )? UPDATE ( OR ROLLBACK | OR ABORT | OR REPLACE | OR FAIL | OR IGNORE )? qualified_table_name
SET column_name '=' expr ( ',' column_name '=' expr )* ( WHERE expr )?
( ( ORDER BY ordering_term ( ',' ordering_term )* )?
LIMIT expr ( ( OFFSET | ',' ) expr )? )?

qualified_table_name ::= ( database_name '.' )? table_name ( INDEXED BY index_name | NOT INDEXED )?

vacuum_stmt ::= VACUUM

// TODO: comments
