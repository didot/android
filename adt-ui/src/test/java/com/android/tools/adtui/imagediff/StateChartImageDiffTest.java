/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.tools.adtui.imagediff;

import com.android.tools.adtui.chart.StateChart;
import com.android.tools.adtui.model.DefaultDataSeries;
import com.android.tools.adtui.model.RangedSeries;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;

import java.awt.*;
import java.util.ArrayList;
import java.util.EnumMap;
import java.util.List;

public class StateChartImageDiffTest extends BaseImageDiffTest {

  private enum TestState {
    NONE,
    STATE1,
    STATE2
  }

  /**
   * Arbitrary values to be added in the state charts.
   */
  private static final TestState[] MY_VALUES = {TestState.NONE, TestState.STATE1, TestState.STATE2, TestState.NONE, TestState.STATE1,
    TestState.STATE2};

  /**
   * Arbitrary flags to determine if a new state should be added to a state chart at some iteration.
   */
  private static final boolean[] NEW_STATE_CONTROL = {true, false, false, false, true, false, false};

  /**
   * Stores the index of the flag that will determine whether a value is going to be inserted in a state chart.
   */
  private int myNewStateControlArrayIndex;

  /**
   * Stores the index of the next value to be inserted in a state chart.
   */
  private int myValuesArrayIndex;

  private StateChart<TestState> myStateChart;

  private List<DefaultDataSeries<TestState>> myData;

  @Before
  public void setUp() {
    myData = new ArrayList<>();
    myStateChart = new StateChart<>(getTestStateColor());
    myContentPane.add(myStateChart, BorderLayout.CENTER);
    myComponents.add(myStateChart);
  }

  @Test
  public void testSimpleStateChart() {
    // Create a simple state chart with only one series
    doTestStateChart("simple_state_chart_baseline.png", this::addSeries);
  }

  @Test
  public void testMultipleSeriesStateChart() {
    doTestStateChart("multiple_series_state_chart_baseline.png", () -> {
      // Create a state chart with multiple series
      addSeries();
      addSeries();
    });
  }

  @Test
  @Ignore("It's currently displaying 3.4% difference on Linux, which is more than expected. We need time to investigate the reason.")
  public void testTextStateChart() {
    // The component generated by this test is mostly composed by texts, so it's better to use a font that is similar across different OS.
    myStateChart.setFont(ImageDiffUtil.DEFAULT_IMG_DIFF_FONT);
    // It's important to notice the fonts are similar, not exactly the same. Therefore, the threshold for image similarity is overridden by
    // a higher value than the default one in this test.
    float thresholdSimilarityOverride = 1.5f;
    doTestStateChart("text_state_chart_baseline.png", () -> {
      // Set the render mode of the state chart to text
      myStateChart.setRenderMode(StateChart.RenderMode.TEXT);
      // Add a considerable amount of series to the state chart,
      // because the text of a single state chart doesn't occupy a lot of the image
      for (int i = 0; i < 15; i++) {
        addSeries();
      }
    }, thresholdSimilarityOverride);
  }

  @Test
  public void testArcHeightWidthStateChart() {
    doTestStateChart("arc_height_width_state_chart_baseline.png", () -> {
      // Modify arc height and width of state chart
      myStateChart.setArcHeight(0.75f);
      myStateChart.setArcWidth(0.75f);
      addSeries();
    });
  }

  /**
   * Test that generated main component is similar enough to baseline image.
   *
   * TODO: consider moving to a base class that contains logic common to chart components tests
   *
   * @param baselineFilename filename of baseline image
   * @param stateChartGenerator code to generate the state chart corresponding to the test
   * @param similarityThreshold how much (in percent) the baseline and the generated images can differ to be considered similar
   */
  private void doTestStateChart(String baselineFilename, Runnable stateChartGenerator, float similarityThreshold) {
    // Generate the state chart corresponding to the current test
    stateChartGenerator.run();

    // Register the chart components in the choreographer
    myChoreographer.register(myComponents);

    // Add data to state chart
    generateTestData();

    // Compare baseline image with the one generated from main component
    ImageDiffUtil.assertImagesSimilar(baselineFilename, myContentPane, similarityThreshold);
  }

  private void doTestStateChart(String baselineFilename, Runnable stateChartGenerator) {
    doTestStateChart(baselineFilename, stateChartGenerator, ImageDiffUtil.DEFAULT_IMAGE_DIFF_PERCENT_THRESHOLD);
  }

  private static EnumMap<TestState, Color> getTestStateColor() {
    EnumMap<TestState, Color> colors = new EnumMap<>(TestState.class);
    colors.put(TestState.NONE, new Color(0, 0, 0, 0));
    colors.put(TestState.STATE1, Color.RED);
    colors.put(TestState.STATE2, Color.BLUE);
    return colors;
  }

  /**
   * Add a series to the state chart.
   */
  private void addSeries() {
    DefaultDataSeries<TestState> series = new DefaultDataSeries<>();
    RangedSeries<TestState> rangedSeries = new RangedSeries<>(myXRange, series);
    myData.add(series);
    myStateChart.addSeries(rangedSeries);
  }

  private void generateTestData() {
    for (int i = 0; i < TOTAL_VALUES; i++) {
      for (DefaultDataSeries<TestState> series : myData) {
        if (NEW_STATE_CONTROL[myNewStateControlArrayIndex++]) {
          int valueIndex = myValuesArrayIndex++ % MY_VALUES.length;
          // Don't add repeated states
          if (series.size() == 0 || series.getY(series.size() - 1) != MY_VALUES[valueIndex]) {
            series.add(myCurrentTimeUs, MY_VALUES[valueIndex]);
          }
        }
        myNewStateControlArrayIndex %= NEW_STATE_CONTROL.length;
      }
      myCurrentTimeUs += TIME_DELTA_US;
    }
    myChoreographer.step();
  }
}
