<html>
<!--
This HTML file is the swingp visualizer.

The basic architecture is based on a cooperative multithreading model, with the two functional units as follows:
1) An HTTP long-poller that polls Studio for swingp render stats.
    * Each fetch may return one or more swingp frame renders containing multiple threads.
    * The data is encoded via a simple bytes_length + content_bytes[bytes_length] encoding.
    * Each content_bytes[bytes_length] is a complete JSON tree structure, in the pattern of [ThreadStat+].
    * During processing of each ThreadStat, rectangles are generated for rendered components' bounds, and frame bounds are (perhaps) updated.
2) A render loop that takes the rectangles and bounds generated/updated in the poller functional unit, and renders them to the canvas.
    * The canvas is hardcoded to render at 1/4 of Swing's resolution.
    * The 1/4 resolution might not be suitable for high DPI displays -- one can change the frameScale and reload the page.
    * Each rectangle is re-rendered according to a time-based alpha decay.
    * Rectangles' alpha are tied to the parent JSON render tree's lifetime (so all rectangles generated by a single JSON tree shares alpha).
    * Primary (main window) is rendered in green, and secondary (popups and other heavy weight components on top) are rendered in red.
-->
<body>
    <form>
        Filter Root: <input type="text" id="root_filter_element" placeholder="e.g. SomeAwtOrSwingComponentType"><br>
    </form>
    <canvas width="1280" height="1024" id="canvas" />
    <script>

        c = document.getElementById("canvas");
        var ctx = c.getContext("2d");

        var PRIMARY_COLOR = '33, 145, 251, ';
        var SECONDARY_COLOR = '186, 39, 74, ';
        var PRIMARY_BORDER_COLOR = '140, 222, 220, ';
        var SECONDARY_BORDER_COLOR = '132, 28, 38, ';
        var FADE_TIME = 250;
        var OPACITY = 0.05;

        var minWindowX = 100000;
        var minWindowY = 100000;

        var textDecoder = new TextDecoder("utf-8");

        var windows = {};
        var buffers = {};

        var rectGroups = [];
        var lastStartLoop = window.performance.now();
        var mostRecentFrameBounds = [0, 0, 1600, 1200];
        var frameScale = 0.25;
        // An element which, if set, means only elements in that subtree should render.
        var rootFilterElement = document.getElementById("root_filter_element");

        ctx.fillStyle = 'rgb(0,0,0)';
        fillRect(
            ctx,
            mostRecentFrameBounds[0],
            mostRecentFrameBounds[1],
            mostRecentFrameBounds[2],
            mostRecentFrameBounds[3]);

        function fillRect(context, x, y, w, h) {
            context.fillRect(x * frameScale, y * frameScale, w * frameScale, h * frameScale);
        }

        function strokeRect(context, x, y, w, h) {
            context.strokeRect(x * frameScale, y * frameScale, w * frameScale, h * frameScale);
        }

        // Main render loop to process all rectangles and frame resizes.
        function render() {
            var startLoop = window.performance.now();
            var timeDiff = startLoop - lastStartLoop;
            lastStartLoop = startLoop;

            var numGroups = rectGroups.length;
            if (numGroups === 0) {
                return;
            }

            // Calculate what needs to be cleared if the main window has resized.
            var clearSize = mostRecentFrameBounds.slice();
            mostRecentFrameBounds = rectGroups[rectGroups.length - 1].ideRootPaneBounds.slice();
            for (var i = 0; i < numGroups; i++) {
                var ideBounds = rectGroups[i].ideRootPaneBounds;
                clearSize = [
                    Math.min(clearSize[0], ideBounds[0]),
                    Math.min(clearSize[1], ideBounds[1]),
                    Math.max(clearSize[2] + clearSize[0], ideBounds[0] + ideBounds[2]), // Record the right-most x-coordinate of the clear rectangle.
                    Math.max(clearSize[3] + clearSize[1], ideBounds[1] + ideBounds[3])  // Record the bottom-most y-coordinate side of the clear rectangle.
                ];
            }
            clearSize[2] -= clearSize[0]; // Recover the width.
            clearSize[3] -= clearSize[1]; // Recover the height.

            if (mostRecentFrameBounds[0] !== clearSize[0] ||
                    mostRecentFrameBounds[1] !== clearSize[1] ||
                    mostRecentFrameBounds[2] !== clearSize[2] ||
                    mostRecentFrameBounds[3] !== clearSize[3]) {
                ctx.fillStyle = 'rgb(255,255,255)';
                // The floor and ceil deal with partial clears due to subpixel coordinates.
                fillRect(
                    ctx,
                    Math.floor(clearSize[0]),
                    Math.floor(clearSize[1]),
                    Math.ceil((clearSize[0] + clearSize[2]) - Math.floor(clearSize[0])),
                    Math.ceil((clearSize[1] + clearSize[3]) - Math.floor(clearSize[1])));
            }

            ctx.fillStyle = 'rgb(0,0,0,255)';
            fillRect(ctx, mostRecentFrameBounds[0], mostRecentFrameBounds[1], mostRecentFrameBounds[2], mostRecentFrameBounds[3]);
            var alphaReduction = timeDiff / FADE_TIME * OPACITY;

            for (var i = 0; i < numGroups; i++) {
                var rectGroup = rectGroups.shift();
                if (rectGroup.alpha <= alphaReduction) {
                    continue;
                }
                if (rectGroup.ideRootPaneBounds[0] != mostRecentFrameBounds[0] ||
                        rectGroup.ideRootPaneBounds[1] != mostRecentFrameBounds[1] ||
                        rectGroup.ideRootPaneBounds[2] != mostRecentFrameBounds[2] ||
                        rectGroup.ideRootPaneBounds[3] != mostRecentFrameBounds[3]) {
                    continue;
                }

                rectGroup.alpha -= alphaReduction;
                rectGroups.push(rectGroup);

                ctx.strokeStyle = 'rgba(' + PRIMARY_BORDER_COLOR + rectGroup.alpha + ')';
                ctx.fillStyle = 'rgba(' + PRIMARY_COLOR + rectGroup.alpha + ')';
                for (var j in rectGroup.primary) {
                    var rect = rectGroup.primary[j];
                    // The OS window bounds are set via the OS while the content bounds are set via Swing.
                    // The difference causes rectangles to get drawn outside of the window bounds.
                    // One way to fix this is to clamp the fillRect to the window bounds here.
                    fillRect(ctx, rect[0], rect[1], rect[2], rect[3]);
                    strokeRect(ctx, rect[0], rect[1], rect[2], rect[3]);
                }

                if (rectGroup.secondary) {
                    ctx.strokeStyle = 'rgba(' + SECONDARY_BORDER_COLOR + rectGroup.alpha + ')';
                    ctx.fillStyle = 'rgba(' + SECONDARY_COLOR + rectGroup.alpha + ')'
                    for (var j in rectGroup.secondary) {
                        var rect = rectGroup.secondary[j];
                        fillRect(ctx, rect[0], rect[1], rect[2], rect[3]);
                        strokeRect(ctx, rect[0], rect[1], rect[2], rect[3]);
                    }
                }
            }

            var startLoop = window.performance.now();
        }

        /**
         * Recursively ingests the JSON tree rooted at the ThreadStat level.
         *
         * @param result Stateful output of the method.
         * @param node The swingp node being processed at this step of the recursion.
         * @param anchor Updated translate position for use by the current node.
         * @param windowNode The heavy weight window in which the current node may fall under.
         * @param isPrimary Whether or not the current node resides under the main heavy weight Window, or some secondary Window (e.g. popup).
         * @param tiledOffset If the painting is done via tiled repaint manager strategy, we need to account for an extra offset.
         * @param rootFilter A string representing a filter for nodes to be rendered (by Java class), or null for no filter.
         */
        function ingest(result, node, anchor, windowNode, isPrimary, tiledOffset, rootFilter) {
            var xform = node.xform;

            if (node.classType == "ThreadStat") {
                for (event in node.events) {
                    ingest(result, node.events[event], anchor, windowNode, isPrimary, tiledOffset, rootFilter);
                }
                return;
            }

            var newAnchor = anchor.slice(); // Anchor should always be in device space (e.g. in HiDPI space if HiDPI is available).
            if (node.classType === "WindowPaintMethodStat") {
                // We hit this node when there are more than one heavy weight component being rendered (e.g. main window + tooltip).
                ownerWindowId = node.ownerWindowId;
                var parentPosition = windows[ownerWindowId] ? windows[ownerWindowId].anchor : [0, 0];
                newAnchor = [
                    node.location[0] * xform[0] + xform[4] + parentPosition[0],
                    node.location[1] * xform[3] + xform[5] + parentPosition[1],
                ];
                windowNode = {"anchor": newAnchor.slice()};
                windows[node.windowId] = windowNode;
            }
            else if (node.classType === "BufferStrategyPaintMethodStat") {
                if (!node.isBufferStrategy) {
                    newAnchor[0] += tiledOffset[0];
                    newAnchor[1] += tiledOffset[1];
                }
            }
            else if (node.classType === "PaintImmediatelyMethodStat") {
                if (node.bufferType === "IdeRootPane") {
                    result.ideRootPaneBounds = [
                        node.bufferBounds[0] * xform[0],
                        node.bufferBounds[1] * xform[3],
                        node.bufferBounds[2] * xform[0],
                        node.bufferBounds[3] * xform[3]
                    ];
                }
                else {
                    var windowAnchor = [0, 0];
                    if (windowNode !== null) {
                        buffers[node.bufferId] = {
                            "window": windowNode,
                            "bufferType": node.bufferType,
                        }
                        windowAnchor = windowNode.anchor;
                    }
                    else if (buffers[node.bufferId]) {
                        windowAnchor = buffers[node.bufferId].window.anchor;
                    }
                    newAnchor[0] = windowAnchor[0];
                    newAnchor[1] = windowAnchor[1];
                    isPrimary = false;
                }
                newAnchor[0] += node.constrain[0];
                newAnchor[1] += node.constrain[1];
                // For tiled buffering, add the (x, y) of the bounds, since the paintImmediatelyImpl method deliberately offsets to render to the top-left corner of the buffer.
                tiledOffset = [node.bounds[0] * xform[0], node.bounds[1] * xform[3]];
            }
            else if (node.classType === "PaintComponentMethodStat" && !node.isImage && isRootFilterDisabled(rootFilter)) {
                bounds = node.clip;

                var rect = [
                    bounds[0] * xform[0] + xform[4] + newAnchor[0],
                    bounds[1] * xform[3] + xform[5] + newAnchor[1],
                    bounds[2] * xform[0],
                    bounds[3] * xform[3]
                ];
                isPrimary ? result.primary.push(rect) : result.secondary.push(rect);
            }
            else if (node.classType === "PaintChildrenMethodStat" && isRootFilterEnabled(rootFilter)) {
                rootFilter = node.pathToRoot.includes(rootFilter) ? null : rootFilter;
            }

            for (i in node.callee) {
                ingest(result, node.callee[i], newAnchor, windowNode, isPrimary, tiledOffset, rootFilter);
            }
        }

        function isRootFilterEnabled(rootFilter) {
            return !!rootFilter;
        }

        function isRootFilterDisabled(rootFilter) {
            return !rootFilter;
        }

        // Process each complete JSON tree, and split up ThreadStats individually for processing.
        function processInput(rootNode) {
            var result = {
                "alpha": OPACITY,
                "primary": [],
                "secondary": [],
                "ideRootPaneBounds": mostRecentFrameBounds.slice()
            };
            var rootFilter = rootFilterElement.value;
            for (var i = 0; i < rootNode.length; i++) {
                ingest(result, rootNode[i], [0.0, 0.0], null, true, [0.0, 0.0], isRootFilterEnabled(rootFilter) ? rootFilter : null);
            }
            rectGroups.push(result);
        }

        var startPoll = window.performance.now();
        var endPoll = 0;
        var endParse = 0;
        var endIngest = 0;

        // Long-poll the server in Studio.
        function poll() {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'http://localhost:61642', true);
            xhr.responseType = "arraybuffer";
            xhr.seenBytes = 0;
            xhr.onload = function() {
                endPoll = window.performance.now();

                var newData = xhr.response;
                var offset = 0;
                while (offset < newData.byteLength) {
                    // The response is a simple encoding of [(int4 size, byte[size])+].
                    // I.e. repeats of four-byte int "size" followed by a byte buffer of "size" length.
                    var sizeArray = new Uint8Array(newData, offset, 4);
                    var size = (sizeArray[0] | sizeArray[1] << 8 | sizeArray[2] << 16 | sizeArray[3] << 24) >>> 0;
                    offset += 4;
                    var jsonChunk = textDecoder.decode(newData.slice(offset, offset+size));
                    offset += size;
                    var rootNode = JSON.parse(jsonChunk);
                    processInput(rootNode);
                }

                endIngest = window.performance.now();
                if (endIngest - endParse > 5)
                    console.log("Ingest time: " + (endIngest - endPoll));

                startPoll = window.performance.now();

                newData = null;
                rootNode = null;
                poll(); // long poll
            };
            xhr.addEventListener("error", function (e) {
                console.log("error: " + e);
            });
            xhr.send();
        }
        poll();

        setInterval(render, 17);
    </script>
</body>

</html>