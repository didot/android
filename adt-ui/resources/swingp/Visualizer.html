<html>
<!--
This HTML file is the swingp visualizer.

The basic architecture is based on a cooperative multithreading model, with the two functional units as follows:
1) An HTTP long-poller that polls Studio for swingp render stats.
    * Each fetch may return one or more swingp frame renders containing multiple threads.
    * The data is encoded via a simple bytes_length + content_bytes[bytes_length] encoding.
    * Each content_bytes[bytes_length] is a complete JSON tree structure, in the pattern of [ThreadStat+].
    * During processing of each ThreadStat, rectangles are generated for rendered components' bounds, and frame bounds are (perhaps) updated.
2) A render loop that takes the rectangles and bounds generated/updated in the poller functional unit, and renders them to the canvas.
    * The canvas is hardcoded to render at 1/4 of Swing's resolution.
    * The 1/4 resolution might not be suitable for high DPI displays -- one can change the frameScale and reload the page.
    * Each rectangle is re-rendered according to a time-based alpha decay.
    * Rectangles' alpha are tied to the parent JSON render tree's lifetime (so all rectangles generated by a single JSON tree shares alpha).
    * Primary (main window) is rendered in green, and secondary (popups and other heavy weight components on top) are rendered in red.
-->
<body>
    <canvas width="1280" height="1024" id="canvas" />
    <script>

        c = document.getElementById("canvas");
        var ctx = c.getContext("2d");

        var PRIMARY_COLOR = '50, 255, 50, ';
        var SECONDARY_COLOR = '255, 50, 50, ';
        var BORDER_COLOR = '255, 255, 255, ';
        var FADE_TIME = 250;
        var OPACITY = 0.05;

        var minWindowX = 100000;
        var minWindowY = 100000;

        var textDecoder = new TextDecoder("utf-8");

        var rectGroups = [];
        var windows = {};
        var lastStartLoop = window.performance.now();
        var mostRecentFrameBounds = [0, 0, 800, 600];
        var frameScale = 0.25;

        ctx.fillStyle = 'rgb(0,0,0,255)';
        ctx.fillRect(mostRecentFrameBounds[0], mostRecentFrameBounds[1], mostRecentFrameBounds[2], mostRecentFrameBounds[3]);

        // Main render loop to process all rectangles and frame resizes.
        function render() {
            var startLoop = window.performance.now();
            var timeDiff = startLoop - lastStartLoop;
            lastStartLoop = startLoop;

            var numGroups = rectGroups.length;
            if (numGroups === 0) {
                return;
            }

            // Calculate what needs to be cleared if the main window has resized.
            var clearSize = mostRecentFrameBounds.slice();
            mostRecentFrameBounds = rectGroups[rectGroups.length - 1].ideRootPaneBounds.slice();
            for (var i = 0; i < numGroups; i++) {
                var ideBounds = rectGroups[i].ideRootPaneBounds;
                clearSize = [
                    Math.min(clearSize[0], ideBounds[0]),
                    Math.min(clearSize[1], ideBounds[1]),
                    Math.max(clearSize[2], ideBounds[0] + ideBounds[2]), // Record the right-most x-coordinate of the clear rectangle.
                    Math.max(clearSize[3], ideBounds[1] + ideBounds[3])  // Record the bottom-most y-coordinate side of the clear rectangle.
                ];
            }
            clearSize[2] -= clearSize[0]; // Recover the width.
            clearSize[3] -= clearSize[1]; // Recover the height.

            if (mostRecentFrameBounds[0] !== clearSize[0] ||
                    mostRecentFrameBounds[1] !== clearSize[1] ||
                    mostRecentFrameBounds[2] !== clearSize[2] ||
                    mostRecentFrameBounds[3] !== clearSize[3]) {
                ctx.fillStyle = 'rgb(255,255,255,255)';
                // The floor and ceil deal with partial clears due to subpixel coordinates.
                ctx.fillRect(
                    Math.floor(clearSize[0]),
                    Math.floor(clearSize[1]),
                    Math.ceil(clearSize[0] + clearSize[2]) - Math.floor(clearSize[0]),
                    Math.ceil(clearSize[1] + clearSize[3]) - Math.floor(clearSize[1]));
            }

            ctx.fillStyle = 'rgb(0,0,0,255)';
            ctx.fillRect(mostRecentFrameBounds[0], mostRecentFrameBounds[1], mostRecentFrameBounds[2], mostRecentFrameBounds[3]);
            var alphaReduction = timeDiff / FADE_TIME * OPACITY;

            for (var i = 0; i < numGroups; i++) {
                var rectGroup = rectGroups.shift();
                if (rectGroup.alpha <= alphaReduction) {
                    continue;
                }
                if (rectGroup.ideRootPaneBounds[0] != mostRecentFrameBounds[0] ||
                        rectGroup.ideRootPaneBounds[1] != mostRecentFrameBounds[1] ||
                        rectGroup.ideRootPaneBounds[2] != mostRecentFrameBounds[2] ||
                        rectGroup.ideRootPaneBounds[3] != mostRecentFrameBounds[3]) {
                    continue;
                }

                rectGroup.alpha -= alphaReduction;
                rectGroups.push(rectGroup);

                ctx.strokeStyle = 'rgb(' + BORDER_COLOR + rectGroup.alpha + ')';
                ctx.fillStyle = 'rgb(' + PRIMARY_COLOR + rectGroup.alpha + ')';
                for (var j in rectGroup.primary) {
                    var rect = rectGroup.primary[j];
                    // The OS window bounds are set via the OS while the content bounds are set via Swing.
                    // The difference causes rectangles to get drawn outside of the window bounds.
                    // One way to fix this is to clamp the fillRect to the window bounds here.
                    ctx.fillRect(rect[0], rect[1], rect[2], rect[3]);
                    ctx.strokeRect(rect[0], rect[1], rect[2], rect[3]);
                }

                ctx.fillStyle = 'rgb(' + SECONDARY_COLOR + rectGroup.alpha + ')'
                for (var j in rectGroup.secondary) {
                    var rect = rectGroup.secondary[j];
                    ctx.fillRect(rect[0], rect[1], rect[2], rect[3]);
                    ctx.strokeRect(rect[0], rect[1], rect[2], rect[3]);
                }
            }

            var startLoop = window.performance.now();
        }

        // Recursively ingests the JSON tree rooted at the ThreadStat level.
        function ingest(result, node, anchor, windowNode, isPrimary) {
            var xform = node.__xform;

            if (node.__type == "ThreadStat") {
                for (event in node.__events) {
                    ingest(result, node.__events[event], anchor, windowNode, isPrimary);
                }
                return;
            }

            var newAnchor = anchor.slice();
            if (node.__type === "WindowPaintMethodStat") {
                // We hit this node when there are more than one heavy weight component being rendered (e.g. main window + tooltip).
                newAnchor = [
                    node.__location[0] * xform[0] + xform[4],
                    node.__location[1] * xform[3] + xform[5],
                ];
                windowNode = {"__anchor": newAnchor.slice()};
            }
            else if (node.__type === "PaintImmediatelyMethodStat") {
                if (node.__bufferType === "IdeRootPane") {
                    result.ideRootPaneBounds = [
                        node.__bufferBounds[0] * xform[0] * frameScale,
                        node.__bufferBounds[1] * xform[3] * frameScale,
                        node.__bufferBounds[2] * xform[0] * frameScale,
                        node.__bufferBounds[3] * xform[3] * frameScale
                    ];
                }
                else {
                    if (windowNode !== null) {
                        windowNode.__bufferType = node.__bufferType;
                        windows[node.__bufferId] = windowNode;
                    }
                    newAnchor[0] = windows[node.__bufferId].__anchor[0] + result.ideRootPaneBounds[0];
                    newAnchor[1] = windows[node.__bufferId].__anchor[1] + result.ideRootPaneBounds[1];
                    isPrimary = false;
                }
                // Add the (x, y) of the bounds, since the paintImmediatelyImpl method deliberately offsets to render to the top-left corner of the buffer.
                newAnchor[0] += node.__bounds[0] * xform[0] + node.__constrain[0];
                newAnchor[1] += node.__bounds[1] * xform[3] + node.__constrain[1];
            }
            else if (node.__type === "PaintComponentMethodStat" && !node.__isImage) {
                bounds = node.__clip;

                var rect = [
                    (xform[0] * bounds[0] + xform[1] * bounds[1] + xform[4] + newAnchor[0]) * frameScale,
                    (xform[2] * bounds[0] + xform[3] * bounds[1] + xform[5] + newAnchor[1]) * frameScale,
                    (xform[0] * bounds[2]) * frameScale,
                    (xform[3] * bounds[3]) * frameScale
                ];
                isPrimary ? result.primary.push(rect) : result.secondary.push(rect);
            }

            for (i in node.__callee) {
                ingest(result, node.__callee[i], newAnchor, windowNode, isPrimary);
            }
        }

        // Process each complete JSON tree, and split up ThreadStats individually for processing.
        function processInput(rootNode) {
            var result = {
                "alpha": OPACITY,
                "primary": [],
                "secondary": [],
                "ideRootPaneBounds": mostRecentFrameBounds.slice()
            };
            for (var i = 0; i < rootNode.length; i++) {
                ingest(result, rootNode[i], [0.0, 0.0], null, true);
            }
            rectGroups.push(result);
        }

        var startPoll = window.performance.now();
        var endPoll = 0;
        var endParse = 0;
        var endIngest = 0;

        // Long-poll the server in Studio.
        function poll() {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'http://localhost:61642', true);
            xhr.responseType = "arraybuffer";
            xhr.seenBytes = 0;
            xhr.onload = function() {
                endPoll = window.performance.now();

                var newData = xhr.response;
                var offset = 0;
                while (offset < newData.byteLength) {
                    // The response is a simple encoding of [(int4 size, byte[size])+].
                    // I.e. repeats of four-byte int "size" followed by a byte buffer of "size" length.
                    var sizeArray = new Uint8Array(newData, offset, 4);
                    var size = (sizeArray[0] | sizeArray[1] << 8 | sizeArray[2] << 16 | sizeArray[3] << 24) >>> 0;
                    offset += 4;
                    var jsonChunk = textDecoder.decode(newData.slice(offset, offset+size));
                    offset += size;
                    var rootNode = JSON.parse(jsonChunk);
                    processInput(rootNode);
                }

                endIngest = window.performance.now();
                if (endIngest - endParse > 5)
                    console.log("Ingest time: " + (endIngest - endPoll));

                startPoll = window.performance.now();

                newData = null;
                rootNode = null;
                poll(); // long poll
            };
            xhr.addEventListener("error", function (e) {
                console.log("error: " + e);
            });
            xhr.send();
        }
        poll();

        setInterval(render, 17);
    </script>
</body>

</html>