/*
 * Copyright (C) 2021 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.tools.idea.uibuilder.lint

import com.android.tools.idea.actions.ATF_ISSUES
import com.android.tools.idea.actions.ATF_ISSUES_LATCH
import com.android.tools.idea.common.error.Issue
import com.android.tools.idea.common.error.NlComponentIssueSource
import com.android.tools.idea.flags.StudioFlags
import com.android.tools.idea.uibuilder.surface.NlAtfIssue
import com.intellij.lang.ASTNode
import com.intellij.lang.annotation.AnnotationHolder
import com.intellij.lang.annotation.ExternalAnnotator
import com.intellij.openapi.editor.Editor
import com.intellij.openapi.util.TextRange
import com.intellij.psi.PsiFile
import com.intellij.psi.xml.XmlChildRole
import com.intellij.psi.xml.XmlFile
import com.intellij.psi.xml.XmlTag
import org.jsoup.Jsoup
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit

/** Returns xml tag associated with the issue */
private val NlAtfIssue.tag: XmlTag? get() = (this.source as NlComponentIssueSource).component.tag

/** Returns formatted plain strings (from html description) */
private val NlAtfIssue.formattedDescription: String get() = Jsoup.parse(this.description).text()

/** Returns text range of the name of the component (e.g. EditText, View) */
private val NlAtfIssue.range: TextRange?
  get() {
    tag?.let {
      val nameElement: ASTNode? = XmlChildRole.START_TAG_NAME_FINDER.findChild(it.node)
      return nameElement?.textRange
    }
    return null
  }

/** Wrapper class that holds the list of NlAtfIssues */
class AtfIssueList(var list: HashSet<Issue> = HashSet()) {

  private val atfIssues get() = list.filterIsInstance(NlAtfIssue::class.java)

  fun add(issues: HashSet<Issue>) {
    list = issues
  }

  /** Search the issue associated with the xml tag. Useful for debugging using visitor later. */
  fun find(tag: XmlTag): NlAtfIssue? {
    atfIssues.forEach {
      if (it.tag == tag) {
        return it
      }
    }
    return null
  }

  /** Show the issues using the annotation holder. */
  fun show(holder: AnnotationHolder) {
    atfIssues.forEach { issue ->
      val builder = holder.newAnnotation(issue.severity, issue.formattedDescription)
      issue.range?.let {
        builder.range(it)
      }
      builder.needsUpdateOnTyping(true).create()
    }
  }

  override fun toString(): String {
    return "issues size : ${list.size}"
  }
}

/** Holds render issue generated by atf */
object AtfIssueListUserDataHandler {

  private fun get(file: PsiFile): AtfIssueList {
    var atfIssues = file.getUserData(ATF_ISSUES)
    if (atfIssues == null) {
      atfIssues = AtfIssueList()
      file.putUserData(ATF_ISSUES, atfIssues)
    }
    return atfIssues
  }

  fun updateIssues(file: XmlFile, issues: HashSet<Issue>) {
    val atfIssues = get(file)
    atfIssues.add(issues)
    getLatch(file).countDown()
  }

  @Synchronized
  fun getLatch(file: PsiFile): CountDownLatch {
    var latch = file.getUserData(ATF_ISSUES_LATCH)
    if (latch == null) {
      latch = CountDownLatch(1)
      file.putUserData(ATF_ISSUES_LATCH, latch)
    }
    return latch
  }

  @Synchronized
  fun resetLatch(file: PsiFile) {
    file.putUserData(ATF_ISSUES_LATCH, CountDownLatch(1))
  }
}

/** External Annotator that takes atf issues and display them to the common Problems panel. */
class AtfIssueExternalAnnotator : ExternalAnnotator<PsiFile, AtfIssueList>() {

  companion object {
    /** Default wait time in [doAnnotate] */
    const val WAIT_MS = 3000L
  }

  override fun collectInformation(file: PsiFile): PsiFile? {
    return collectInfo(file)
  }

  override fun collectInformation(file: PsiFile, editor: Editor, hasErrors: Boolean): PsiFile? {
    return collectInfo(file)
  }

  private fun collectInfo(file: PsiFile): PsiFile? {
    if (!StudioFlags.NELE_LAYOUT_SCANNER_COMMON_ERROR_PANEL.get()) {
      return null
    }
    return file
  }

  override fun doAnnotate(collectedInfo: PsiFile?): AtfIssueList? {
    if (!StudioFlags.NELE_LAYOUT_SCANNER_COMMON_ERROR_PANEL.get() || collectedInfo == null) {
      return null
    }

    /**
     * TODO: b/184886493 Fix the bug with common problems panel.
     *
     * Repro: Switch between two files that reports atf rapidly, close both and re-open
     *
     * Problem:
     * 1) [collectedInfo] is not always current to what is displaying to users between switching. The
     *    annotator annotates and applies wrong file at times.
     * 2) [PsiFile.getUserData] doesn't always retain the right information. It often returns bogus
     *    data that does not match what was stored before closing the file.
     *
     * #1 doesn't happen often but #2 is more consistently repro-able.
     *
     * To try:
     * 1) Find file close listener and clear user data cache from the file when closing.
     * 2) Investigate call stack between collectInfo and doAnnotate
     * */
    val latch = AtfIssueListUserDataHandler.getLatch(collectedInfo)
    latch.await(WAIT_MS, TimeUnit.MILLISECONDS)

    return collectedInfo.getUserData(ATF_ISSUES)
  }

  override fun apply(file: PsiFile, annotationResult: AtfIssueList?, holder: AnnotationHolder) {
    AtfIssueListUserDataHandler.resetLatch(file)
    annotationResult?.show(holder)
  }
}
