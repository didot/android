/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.tools.datastore;

import com.android.annotations.VisibleForTesting;
import com.android.tools.analytics.UsageTracker;
import com.android.tools.datastore.database.DataStoreTable;
import com.android.tools.datastore.service.*;
import com.android.tools.nativeSymbolizer.NativeSymbolizer;
import com.android.tools.nativeSymbolizer.NopSymbolizer;
import com.android.tools.profiler.proto.*;
import com.google.wireless.android.sdk.stats.AndroidProfilerDbStats;
import com.google.wireless.android.sdk.stats.AndroidStudioEvent;
import io.grpc.*;
import io.grpc.inprocess.InProcessServerBuilder;
import java.util.concurrent.atomic.AtomicLong;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.File;
import java.io.IOException;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

import static com.android.tools.datastore.DataStoreDatabase.Characteristic.DURABLE;

/**
 * Primary class that initializes the Datastore. This class currently manages connections to perfd and sets up the DataStore service.
 */
public class DataStoreService implements DataStoreTable.DataStoreTableErrorCallback {
  /**
   * DB report timings are set to occur relatively infrequently, as they include a fair amount of
   * data (~100 bytes). Ideally, we would just send a single reporting event, when the user stopped
   * profiling, but in that case, we'd possibly lose some data when a user's application crashed,
   * and we'd almost never count users who leave their IDE open forever. So, instead, we adopt a
   * slow but steady sampling strategy.
   */
  private static final long REPORT_INITIAL_DELAY = TimeUnit.MINUTES.toMillis(15);
  private static final long REPORT_PERIOD = TimeUnit.HOURS.toMillis(1);
  /**
   * Stream 0 is reserved for datastore metadata. Events stored in this stream are generated by the datastore
   * and can be queried via the events pipeline. Example data pushed into this stream are stream connected / disconnected events.
   */
  public static final long DATASTORE_RESERVED_STREAM_ID = -1;

  public static class BackingNamespace {
    public static final BackingNamespace DEFAULT_SHARED_NAMESPACE = new BackingNamespace("default.sql", DURABLE);

    @NotNull public final String myNamespace;
    @NotNull public final DataStoreDatabase.Characteristic myCharacteristic;

    public BackingNamespace(@NotNull String namespace, @NotNull DataStoreDatabase.Characteristic characteristic) {
      myNamespace = namespace;
      myCharacteristic = characteristic;
    }

    @Override
    public int hashCode() {
      return Arrays.hashCode(new Object[]{myNamespace, myCharacteristic});
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof BackingNamespace)) {
        return false;
      }

      BackingNamespace other = (BackingNamespace)obj;
      return myNamespace.equals(other.myNamespace) && myCharacteristic == other.myCharacteristic;
    }
  }

  private LogService.Logger getLogger() {
    return myLogService.getLogger(DataStoreService.class.getCanonicalName());
  }

  @NotNull private final LogService myLogService;
  private final String myDatastoreDirectory;
  private final Map<BackingNamespace, DataStoreDatabase> myDatabases = new HashMap<>();
  private final ServerBuilder myServerBuilder;
  private final Server myServer;
  private final List<ServicePassThrough> myServices = new ArrayList<>();
  private final Consumer<Runnable> myFetchExecutor;
  @NotNull
  private Consumer<Throwable> myNoPiiExceptionHanlder;

  private ProfilerService myProfilerService;
  @NotNull
  private NativeSymbolizer myNativeSymbolizer = new NopSymbolizer();
  private final ServerInterceptor myInterceptor;
  private final Map<DeviceId, DataStoreClient> myConnectedClients = new HashMap<>();

  private final Timer myReportTimer;

  /**
   * The stream id of our next stream. This ID is unique across {@link ProfilerService} sessions and should always increment.
   */
  private AtomicLong myNextStreamId = new AtomicLong(1);

  /**
   * @param fetchExecutor A callback which is given a {@link Runnable} for each datastore service.
   *                      The runnable, when run, begins polling the target service. You probably
   *                      want to run it on a background thread.
   */
  public DataStoreService(@NotNull String serviceName,
                          @NotNull String datastoreDirectory,
                          @NotNull Consumer<Runnable> fetchExecutor,
                          @NotNull LogService logService) {
    this(serviceName, datastoreDirectory, fetchExecutor, logService, null);
  }

  @VisibleForTesting
  public DataStoreService(@NotNull String serviceName,
                          @NotNull String datastoreDirectory,
                          @NotNull Consumer<Runnable> fetchExecutor,
                          @NotNull LogService logService,
                          @Nullable ServerInterceptor interceptor) {
    myLogService = logService;
    myFetchExecutor = fetchExecutor;
    myInterceptor = interceptor;
    myDatastoreDirectory = datastoreDirectory;
    myServerBuilder = InProcessServerBuilder.forName(serviceName).directExecutor();
    myNoPiiExceptionHanlder = (t) -> getLogger().error(t);
    createPollers();
    myServer = myServerBuilder.build();
    try {
      myServer.start();
    }
    catch (IOException ex) {
      getLogger().error(ex.getMessage());
    }

    myReportTimer = new Timer("DataStoreReportTimer");
    myReportTimer.schedule(new ReportTimerTask(), REPORT_INITIAL_DELAY, REPORT_PERIOD);
    DataStoreTable.addDataStoreErrorCallback(this);
  }

  public void setNoPiiExceptionHanlder(@NotNull Consumer<Throwable> noPiiExceptionHanlder) {
    myNoPiiExceptionHanlder = noPiiExceptionHanlder;
  }

  @VisibleForTesting
  public Map<BackingNamespace, DataStoreDatabase> getDatabases() {
    return myDatabases;
  }

  /**
   * Entry point for the datastore pollers and passthrough services are created,
   * and registered as the set of features the datastore supports.
   */
  public void createPollers() {
    myProfilerService = new ProfilerService(this, myFetchExecutor, myLogService);
    registerService(myProfilerService);
    registerService(new EventService(this, myFetchExecutor));
    registerService(new CpuService(this, myFetchExecutor, myLogService));
    registerService(new MemoryService(this, myFetchExecutor, myLogService));
    registerService(new NetworkService(this, myFetchExecutor));
    registerService(new EnergyService(this, myFetchExecutor, myLogService));
  }

  @VisibleForTesting
  @NotNull
  public DataStoreDatabase createDatabase(@NotNull String dbPath,
                                          @NotNull DataStoreDatabase.Characteristic characteristic,
                                          Consumer<Throwable> noPiiExceptionHandler) {
    return new DataStoreDatabase(dbPath, characteristic, myLogService, noPiiExceptionHandler);
  }

  /**
   * Register's the service with the DataStore and manages the list of pass through to initialize a connection to the appropriate device.
   *
   * @param service The service to register with the datastore. This service will be setup as a listener for studio to talk to.
   */
  @VisibleForTesting
  void registerService(@NotNull ServicePassThrough service) {
    myServices.add(service);
    List<BackingNamespace> namespaces = service.getBackingNamespaces();
    namespaces.forEach(namespace -> {
      assert !namespace.myNamespace.isEmpty();
      DataStoreDatabase db = myDatabases.computeIfAbsent(namespace, backingNamespace -> createDatabase(
        myDatastoreDirectory + backingNamespace.myNamespace, backingNamespace.myCharacteristic, myNoPiiExceptionHanlder));
      service.setBackingStore(namespace, db.getConnection());
    });

    // Build server and start listening for RPC calls for the registered service
    if (myInterceptor != null) {
      myServerBuilder.addService(ServerInterceptors.intercept(service.bindService(), myInterceptor));
    }
    else {
      myServerBuilder.addService(service.bindService());
    }
  }

  /**
   * When a new device is connected this function tells the DataStore how to connect to that device and creates a channel for the device.
   *
   * @param channel communication channel for the datastore to connect to perfd on.
   */
  public void connect(@NotNull ManagedChannel channel) {
    myProfilerService.startMonitoring(channel);
  }

  /**
   * Connects a channel to the new event pipeline. To make the association between channel and stream, we need to pass some metadata about
   * the channel as well. The stream passed in this way will get a stream id set on it and an event created for it. As such the caller can
   * query for the stream information via the
   * {@link ProfilerServiceGrpc.ProfilerServiceBlockingStub#getEventGroups(Profiler.GetEventGroupsRequest)} call.
   */
  public void connect(@NotNull Common.Stream stream, @NotNull ManagedChannel channel) {
    assert stream.getStreamId() != 0;
    myProfilerService.startPolling(stream, channel);
  }

  public long getUniqueStreamId() {
    return myNextStreamId.getAndIncrement();
  }

  /**
   * Sets a symbolizer that is used to transform native backtraces into human readable callstacks.
   */
  public void setNativeSymbolizer(@NotNull NativeSymbolizer symbolizer) {
    myNativeSymbolizer = symbolizer;
  }

  /**
   * Gets native symbolizer to be used for JNI tracking
   */
  @NotNull
  public NativeSymbolizer getNativeSymbolizer() {
    return myNativeSymbolizer;
  }

  /**
   * Disconnect from the specified channel.
   */
  public void disconnect(@NotNull DeviceId deviceId) {
    if (myConnectedClients.containsKey(deviceId)) {
      DataStoreClient client = myConnectedClients.remove(deviceId);
      client.shutdownNow();
      myProfilerService.stopMonitoring(client.getChannel());
    }
  }

  public void shutdown() {
    myReportTimer.cancel();
    myServer.shutdownNow();
    for (DataStoreClient client : myConnectedClients.values()) {
      client.shutdownNow();
    }
    myConnectedClients.clear();
    myDatabases.forEach((name, db) -> db.disconnect());
    DataStoreTable.removeDataStoreErrorCallback(this);
  }


  @VisibleForTesting
  List<ServicePassThrough> getRegisteredServices() {
    return myServices;
  }

  public void setConnectedClients(@NotNull DeviceId deviceId, @NotNull Channel channel) {
    if (!myConnectedClients.containsKey(deviceId)) {
      myConnectedClients.put(deviceId, new DataStoreClient(channel));
    }
  }

  public CpuServiceGrpc.CpuServiceBlockingStub getCpuClient(@NotNull DeviceId deviceId) {
    return myConnectedClients.containsKey(deviceId) ? myConnectedClients.get(deviceId).getCpuClient() : null;
  }

  public EnergyServiceGrpc.EnergyServiceBlockingStub getEnergyClient(@NotNull DeviceId deviceId) {
    return myConnectedClients.containsKey(deviceId) ? myConnectedClients.get(deviceId).getEnergyClient() : null;
  }

  public EventServiceGrpc.EventServiceBlockingStub getEventClient(@NotNull DeviceId deviceId) {
    return myConnectedClients.containsKey(deviceId) ? myConnectedClients.get(deviceId).getEventClient() : null;
  }

  public NetworkServiceGrpc.NetworkServiceBlockingStub getNetworkClient(@NotNull DeviceId deviceId) {
    return myConnectedClients.containsKey(deviceId) ? myConnectedClients.get(deviceId).getNetworkClient() : null;
  }

  public MemoryServiceGrpc.MemoryServiceBlockingStub getMemoryClient(@NotNull DeviceId deviceId) {
    return myConnectedClients.containsKey(deviceId) ? myConnectedClients.get(deviceId).getMemoryClient() : null;
  }

  public ProfilerServiceGrpc.ProfilerServiceBlockingStub getProfilerClient(@NotNull DeviceId deviceId) {
    return myConnectedClients.containsKey(deviceId) ? myConnectedClients.get(deviceId).getProfilerClient() : null;
  }

  @Override
  public void onDataStoreError(Throwable t) {
    myNoPiiExceptionHanlder.accept(t);
  }

  /**
   * This class is used to manage the stub to each service per device.
   */
  private static class DataStoreClient {
    @NotNull private final Channel myChannel;
    @NotNull private final ProfilerServiceGrpc.ProfilerServiceBlockingStub myProfilerClient;
    @NotNull private final CpuServiceGrpc.CpuServiceBlockingStub myCpuClient;
    @NotNull private final EnergyServiceGrpc.EnergyServiceBlockingStub myEnergyClient;
    @NotNull private final EventServiceGrpc.EventServiceBlockingStub myEventClient;
    @NotNull private final MemoryServiceGrpc.MemoryServiceBlockingStub myMemoryClient;
    @NotNull private final NetworkServiceGrpc.NetworkServiceBlockingStub myNetworkClient;

    public DataStoreClient(@NotNull Channel channel) {
      myChannel = channel;
      myProfilerClient = ProfilerServiceGrpc.newBlockingStub(channel);
      myCpuClient = CpuServiceGrpc.newBlockingStub(channel);
      myEnergyClient = EnergyServiceGrpc.newBlockingStub(channel);
      myEventClient = EventServiceGrpc.newBlockingStub(channel);
      myMemoryClient = MemoryServiceGrpc.newBlockingStub(channel);
      myNetworkClient = NetworkServiceGrpc.newBlockingStub(channel);
    }

    @NotNull
    public Channel getChannel() {
      return myChannel;
    }

    @NotNull
    public ProfilerServiceGrpc.ProfilerServiceBlockingStub getProfilerClient() {
      return myProfilerClient;
    }

    @NotNull
    public CpuServiceGrpc.CpuServiceBlockingStub getCpuClient() {
      return myCpuClient;
    }

    @NotNull
    public EnergyServiceGrpc.EnergyServiceBlockingStub getEnergyClient() {
      return myEnergyClient;
    }

    @NotNull
    public EventServiceGrpc.EventServiceBlockingStub getEventClient() {
      return myEventClient;
    }

    @NotNull
    public MemoryServiceGrpc.MemoryServiceBlockingStub getMemoryClient() {
      return myMemoryClient;
    }

    @NotNull
    public NetworkServiceGrpc.NetworkServiceBlockingStub getNetworkClient() {
      return myNetworkClient;
    }

    public void shutdownNow() {
      // The check is needed because the test replace the channel with a PassthroughChannel instead of a managed channel.
      if (myChannel instanceof ManagedChannel) {
        ((ManagedChannel)myChannel).shutdownNow();
      }
    }
  }

  private final class ReportTimerTask extends TimerTask {
    private long myStartTime = System.nanoTime();

    @Override
    public void run() {
      AndroidProfilerDbStats.Builder dbStats = AndroidProfilerDbStats.newBuilder();
      // Cast to int. Unlikely we'll ever have more than 2 billion seconds (e.g. ~60 years) here...
      dbStats.setAgeSec((int)TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - myStartTime));
      collectReport(dbStats);

      AndroidStudioEvent.Builder event = AndroidStudioEvent
        .newBuilder()
        .setKind(AndroidStudioEvent.EventKind.ANDROID_PROFILER_DB_STATS)
        .setAndroidProfilerDbStats(dbStats);

      UsageTracker.log(event);
    }

    private void collectReport(AndroidProfilerDbStats.Builder dbStats) {
      try {
        File dbFile = new File(myDatastoreDirectory, BackingNamespace.DEFAULT_SHARED_NAMESPACE.myNamespace);
        dbStats.setTotalDiskMb((int)(dbFile.length() / 1024 / 1024)); // Bytes -> MB

        for (DataStoreDatabase db : myDatabases.values()) {
          try (
            Statement tableStatement = db.getConnection().createStatement();
            ResultSet tableResults = tableStatement.executeQuery("SELECT name FROM sqlite_master WHERE type='table'")) {
            while (tableResults.next()) {
              String tableName = tableResults.getString(1);
              try (
                Statement sizeStatement = db.getConnection().createStatement();
                ResultSet sizeResult = sizeStatement.executeQuery(String.format("SELECT COUNT(*) FROM %s", tableName))) {
                int tableSize = sizeResult.getInt(1);
                dbStats.addTablesBuilder().setName(tableName).setNumRecords(tableSize).build();
              }
            }
          }
        }
      }
      catch (SQLException ignored) {
      }
    }
  }
}
