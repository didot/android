/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.tools.idea.appinspection.internal

import com.android.tools.app.inspection.AppInspection
import com.android.tools.idea.transport.TransportClient
import com.android.tools.idea.transport.manager.StreamEventQuery
import com.android.tools.idea.transport.manager.TransportStreamChannel
import com.android.tools.idea.transport.manager.TransportStreamEventListener
import com.android.tools.idea.transport.poller.TransportEventListener
import com.android.tools.profiler.proto.Commands
import com.android.tools.profiler.proto.Common
import com.android.tools.profiler.proto.Transport
import com.google.common.annotations.VisibleForTesting
import kotlinx.coroutines.CompletableDeferred
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.asExecutor
import kotlinx.coroutines.withContext
import java.util.concurrent.atomic.AtomicInteger

fun Commands.Command.toExecuteRequest(): Transport.ExecuteRequest = Transport.ExecuteRequest.newBuilder().setCommand(this).build()


/**
 * Small helper class to work with the one exact process and app-inspection events & commands.
 */
class AppInspectionTransport(
  val client: TransportClient,
  val stream: Common.Stream,
  val process: Common.Process,
  val dispatcher: CoroutineDispatcher,
  private val streamChannel: TransportStreamChannel
) {

  companion object {
    private val commandIdGenerator = AtomicInteger(1)

    /**
     * A method which generates a new unique ID each time, to be assigned to an outgoing inspector command.
     *
     * This ID is used to map events from the agent to the correct handler. This method is thread-safe.
     */
    fun generateNextCommandId() = commandIdGenerator.getAndIncrement()

    /**
     * The last value generated by calling [generateNextCommandId]
     *
     * This method is thread-safe.
     */
    @VisibleForTesting
    fun lastGeneratedCommandId() = commandIdGenerator.get() - 1
  }

  /**
   * Utility function to create a [StreamEventQuery] based on this pid.
   */
  fun createStreamEventQuery(
    eventKind: Common.Event.Kind,
    filter: (Common.Event) -> Boolean = { true },
    startTimeNs: () -> Long = { Long.MIN_VALUE }
  ) = StreamEventQuery(
    eventKind = eventKind,
    startTime = startTimeNs,
    filter = filter,
    processId = { process.pid }
  )

  /**
   * Creates a new [TransportEventListener] given the provided filtering criteria.
   *
   * See [TransportStreamEventListener] for more details about what these parameters are.
   */
  fun createStreamEventListener(
    eventKind: Common.Event.Kind,
    filter: (Common.Event) -> Boolean = { true },
    startTimeNs: () -> Long = { Long.MIN_VALUE },
    isTransient: Boolean = false,
    callback: (Common.Event) -> Unit
  ) = TransportStreamEventListener(
    createStreamEventQuery(eventKind, filter, startTimeNs),
    executor = dispatcher.asExecutor(),
    isTransient = isTransient,
    callback = callback
  )

  /**
   * Registers the given listener with poller.
   */
  fun registerEventListener(streamEventListener: TransportStreamEventListener) {
    streamChannel.registerStreamEventListener(streamEventListener)
  }

  fun unregisterEventListener(streamEventListener: TransportStreamEventListener) {
    streamChannel.unregisterStreamEventListener(streamEventListener)
  }

  private fun AppInspection.AppInspectionCommand.toCommand() = Commands.Command.newBuilder()
    .setType(Commands.Command.CommandType.APP_INSPECTION)
    .setStreamId(stream.streamId)
    .setPid(process.pid)
    .setAppInspectionCommand(this).build()

  /**
   * Identical in functionality to [executeCommand] below except it takes an AppInspection [command].
   */
  suspend fun executeCommand(command: AppInspection.AppInspectionCommand,
                             streamEventQuery: StreamEventQuery): Common.Event {
    return executeCommand(command.toCommand().toExecuteRequest(), streamEventQuery)
  }

  /**
   * Executes the provided AppInspection [command] and await for a response that satisfies the [streamEventListener].
   * */
  suspend fun executeCommand(request: Transport.ExecuteRequest,
                             streamEventQuery: StreamEventQuery): Common.Event = withContext(dispatcher) {
    val deferred = CompletableDeferred<Common.Event>()
    val listener = TransportStreamEventListener(streamEventQuery, dispatcher.asExecutor(), false) { event ->
      try {
        deferred.complete(event)
      }
      catch (t: Throwable) {
        deferred.completeExceptionally(t)
      }
    }
    registerEventListener(listener)
    client.transportStub.execute(request)
    try {
      deferred.await()
    }
    finally {
      unregisterEventListener(listener)
    }
  }

  /**
   * Sends a command via the transport pipeline to device. Suspends for a little bit while command executes.
   */
  suspend fun executeCommand(appInspectionCommand: AppInspection.AppInspectionCommand) = withContext(dispatcher) {
    val command = Commands.Command.newBuilder()
      .setType(Commands.Command.CommandType.APP_INSPECTION)
      .setStreamId(stream.streamId)
      .setPid(process.pid)
      .setAppInspectionCommand(appInspectionCommand).build()
    client.transportStub.execute(command.toExecuteRequest())
  }
}